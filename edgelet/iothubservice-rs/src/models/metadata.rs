/*
 * IotHub Gateway Service APIs
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: Service
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct Metadata {
    #[serde(rename = "LastUpdatedUtc", skip_serializing_if = "Option::is_none")]
    last_updated_utc: Option<::models::VariantValueDateTime>,
    #[serde(rename = "LastUpdatedVersion", skip_serializing_if = "Option::is_none")]
    last_updated_version: Option<i64>,
    #[serde(rename = "LastUpdatedBy", skip_serializing_if = "Option::is_none")]
    last_updated_by: Option<String>,
    #[serde(rename = "LastUpdatedByDigest", skip_serializing_if = "Option::is_none")]
    last_updated_by_digest: Option<String>,
    #[serde(rename = "HasChildren", skip_serializing_if = "Option::is_none")]
    has_children: Option<bool>,
    #[serde(rename = "Nested", skip_serializing_if = "Option::is_none")]
    nested: Option<::std::collections::HashMap<String, ::models::Metadata>>,
}

impl Metadata {
    pub fn new() -> Metadata {
        Metadata {
            last_updated_utc: None,
            last_updated_version: None,
            last_updated_by: None,
            last_updated_by_digest: None,
            has_children: None,
            nested: None,
        }
    }

    pub fn set_last_updated_utc(&mut self, last_updated_utc: ::models::VariantValueDateTime) {
        self.last_updated_utc = Some(last_updated_utc);
    }

    pub fn with_last_updated_utc(
        mut self,
        last_updated_utc: ::models::VariantValueDateTime,
    ) -> Metadata {
        self.last_updated_utc = Some(last_updated_utc);
        self
    }

    pub fn last_updated_utc(&self) -> Option<&::models::VariantValueDateTime> {
        self.last_updated_utc.as_ref()
    }

    pub fn reset_last_updated_utc(&mut self) {
        self.last_updated_utc = None;
    }

    pub fn set_last_updated_version(&mut self, last_updated_version: i64) {
        self.last_updated_version = Some(last_updated_version);
    }

    pub fn with_last_updated_version(mut self, last_updated_version: i64) -> Metadata {
        self.last_updated_version = Some(last_updated_version);
        self
    }

    pub fn last_updated_version(&self) -> Option<&i64> {
        self.last_updated_version.as_ref()
    }

    pub fn reset_last_updated_version(&mut self) {
        self.last_updated_version = None;
    }

    pub fn set_last_updated_by(&mut self, last_updated_by: String) {
        self.last_updated_by = Some(last_updated_by);
    }

    pub fn with_last_updated_by(mut self, last_updated_by: String) -> Metadata {
        self.last_updated_by = Some(last_updated_by);
        self
    }

    pub fn last_updated_by(&self) -> Option<&String> {
        self.last_updated_by.as_ref()
    }

    pub fn reset_last_updated_by(&mut self) {
        self.last_updated_by = None;
    }

    pub fn set_last_updated_by_digest(&mut self, last_updated_by_digest: String) {
        self.last_updated_by_digest = Some(last_updated_by_digest);
    }

    pub fn with_last_updated_by_digest(mut self, last_updated_by_digest: String) -> Metadata {
        self.last_updated_by_digest = Some(last_updated_by_digest);
        self
    }

    pub fn last_updated_by_digest(&self) -> Option<&String> {
        self.last_updated_by_digest.as_ref()
    }

    pub fn reset_last_updated_by_digest(&mut self) {
        self.last_updated_by_digest = None;
    }

    pub fn set_has_children(&mut self, has_children: bool) {
        self.has_children = Some(has_children);
    }

    pub fn with_has_children(mut self, has_children: bool) -> Metadata {
        self.has_children = Some(has_children);
        self
    }

    pub fn has_children(&self) -> Option<&bool> {
        self.has_children.as_ref()
    }

    pub fn reset_has_children(&mut self) {
        self.has_children = None;
    }

    pub fn set_nested(&mut self, nested: ::std::collections::HashMap<String, ::models::Metadata>) {
        self.nested = Some(nested);
    }

    pub fn with_nested(
        mut self,
        nested: ::std::collections::HashMap<String, ::models::Metadata>,
    ) -> Metadata {
        self.nested = Some(nested);
        self
    }

    pub fn nested(&self) -> Option<&::std::collections::HashMap<String, ::models::Metadata>> {
        self.nested.as_ref()
    }

    pub fn reset_nested(&mut self) {
        self.nested = None;
    }
}
