/*
 * IotHub Gateway Service APIs
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: Service
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// DeviceTwinInfo : Container of IoT Hub device twin properties and their accessors.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct DeviceTwinInfo {
    /// The deviceId uniquely identifies the device in the IoT hub's identity registry. A case-sensitive string (up to 128 char long) of ASCII 7-bit alphanumeric chars + {'-', ':', '.', '+', '%', '_', '#', '*', '?', '!', '(', ')', ',', '=', '@', ';', '$', '''}.
    #[serde(rename = "DeviceId", skip_serializing_if = "Option::is_none")]
    device_id: Option<String>,
    /// The last time the device connected, received or sent a message. In ISO8601 datetime format in UTC, for example, 2015-01-28T16:24:48.789Z. This does not update if the device uses the HTTP/1 protocol to perform messaging operations.
    #[serde(rename = "LastActivityTimeUtc", skip_serializing_if = "Option::is_none")]
    last_activity_time_utc: Option<::models::VariantValueDateTime>,
    /// Indicates if the device is currently connected to the IoT hub or not.
    #[serde(rename = "IsConnected", skip_serializing_if = "Option::is_none")]
    is_connected: Option<bool>,
    /// The last time the device connected to the IoT hub. In ISO8601 datetime format in UTC, for example, 2015-01-28T16:24:48.789Z. This does not update if the device uses the HTTP/1 protocol to perform messaging operations.
    #[serde(rename = "LastConnectedTimeUtc", skip_serializing_if = "Option::is_none")]
    last_connected_time_utc: Option<::models::VariantValueDateTime>,
    /// Version for device twin, including tags and desired properties
    #[serde(rename = "Version", skip_serializing_if = "Option::is_none")]
    version: Option<i64>,
    /// A JSON document read and written by the solution back end. Tags are not visible to device apps.
    #[serde(rename = "Tags", skip_serializing_if = "Option::is_none")]
    tags: Option<::std::collections::HashMap<String, Value>>,
    /// Used in conjunction with reported properties to synchronize device configuration or condition. Desired properties can only be set by the solution back end and can be read by the device app. The device app can also be notified in real time of changes on the desired properties.
    #[serde(rename = "DesiredProperties", skip_serializing_if = "Option::is_none")]
    desired_properties: Option<::models::DeviceTwinProperties>,
    /// Used in conjunction with desired properties to synchronize device configuration or condition. Reported properties can only be set by the device app and can be read and queried by the solution back end.
    #[serde(rename = "ReportedProperties", skip_serializing_if = "Option::is_none")]
    reported_properties: Option<::models::DeviceTwinProperties>,
    /// Provisioning state of device twin.
    #[serde(rename = "ProvisioningState", skip_serializing_if = "Option::is_none")]
    provisioning_state: Option<String>,
    #[serde(rename = "ModuleId", skip_serializing_if = "Option::is_none")]
    module_id: Option<String>,
    #[serde(rename = "Configurations", skip_serializing_if = "Option::is_none")]
    configurations: Option<::std::collections::HashMap<String, ::models::ConfigurationVersion>>,
    #[serde(rename = "Capabilities", skip_serializing_if = "Option::is_none")]
    capabilities: Option<::models::DeviceCapabilities>,
    #[serde(rename = "Status", skip_serializing_if = "Option::is_none")]
    status: Option<String>,
    #[serde(rename = "StatusReason", skip_serializing_if = "Option::is_none")]
    status_reason: Option<String>,
    #[serde(rename = "StatusUpdatedTime", skip_serializing_if = "Option::is_none")]
    status_updated_time: Option<String>,
    #[serde(rename = "ConnectionState", skip_serializing_if = "Option::is_none")]
    connection_state: Option<String>,
    #[serde(rename = "LastActivityTime", skip_serializing_if = "Option::is_none")]
    last_activity_time: Option<String>,
    #[serde(rename = "CloudToDeviceMessageCount", skip_serializing_if = "Option::is_none")]
    cloud_to_device_message_count: Option<i32>,
    #[serde(rename = "AuthenticationType", skip_serializing_if = "Option::is_none")]
    authentication_type: Option<String>,
    #[serde(rename = "X509Thumbprint", skip_serializing_if = "Option::is_none")]
    x509_thumbprint: Option<::models::X509ThumbprintInfo>,
    #[serde(rename = "DeviceETag", skip_serializing_if = "Option::is_none")]
    device_e_tag: Option<String>,
    #[serde(rename = "TwinVersion", skip_serializing_if = "Option::is_none")]
    twin_version: Option<i64>,
}

impl DeviceTwinInfo {
    /// Container of IoT Hub device twin properties and their accessors.
    pub fn new() -> DeviceTwinInfo {
        DeviceTwinInfo {
            device_id: None,
            last_activity_time_utc: None,
            is_connected: None,
            last_connected_time_utc: None,
            version: None,
            tags: None,
            desired_properties: None,
            reported_properties: None,
            provisioning_state: None,
            module_id: None,
            configurations: None,
            capabilities: None,
            status: None,
            status_reason: None,
            status_updated_time: None,
            connection_state: None,
            last_activity_time: None,
            cloud_to_device_message_count: None,
            authentication_type: None,
            x509_thumbprint: None,
            device_e_tag: None,
            twin_version: None,
        }
    }

    pub fn set_device_id(&mut self, device_id: String) {
        self.device_id = Some(device_id);
    }

    pub fn with_device_id(mut self, device_id: String) -> DeviceTwinInfo {
        self.device_id = Some(device_id);
        self
    }

    pub fn device_id(&self) -> Option<&String> {
        self.device_id.as_ref()
    }

    pub fn reset_device_id(&mut self) {
        self.device_id = None;
    }

    pub fn set_last_activity_time_utc(
        &mut self,
        last_activity_time_utc: ::models::VariantValueDateTime,
    ) {
        self.last_activity_time_utc = Some(last_activity_time_utc);
    }

    pub fn with_last_activity_time_utc(
        mut self,
        last_activity_time_utc: ::models::VariantValueDateTime,
    ) -> DeviceTwinInfo {
        self.last_activity_time_utc = Some(last_activity_time_utc);
        self
    }

    pub fn last_activity_time_utc(&self) -> Option<&::models::VariantValueDateTime> {
        self.last_activity_time_utc.as_ref()
    }

    pub fn reset_last_activity_time_utc(&mut self) {
        self.last_activity_time_utc = None;
    }

    pub fn set_is_connected(&mut self, is_connected: bool) {
        self.is_connected = Some(is_connected);
    }

    pub fn with_is_connected(mut self, is_connected: bool) -> DeviceTwinInfo {
        self.is_connected = Some(is_connected);
        self
    }

    pub fn is_connected(&self) -> Option<&bool> {
        self.is_connected.as_ref()
    }

    pub fn reset_is_connected(&mut self) {
        self.is_connected = None;
    }

    pub fn set_last_connected_time_utc(
        &mut self,
        last_connected_time_utc: ::models::VariantValueDateTime,
    ) {
        self.last_connected_time_utc = Some(last_connected_time_utc);
    }

    pub fn with_last_connected_time_utc(
        mut self,
        last_connected_time_utc: ::models::VariantValueDateTime,
    ) -> DeviceTwinInfo {
        self.last_connected_time_utc = Some(last_connected_time_utc);
        self
    }

    pub fn last_connected_time_utc(&self) -> Option<&::models::VariantValueDateTime> {
        self.last_connected_time_utc.as_ref()
    }

    pub fn reset_last_connected_time_utc(&mut self) {
        self.last_connected_time_utc = None;
    }

    pub fn set_version(&mut self, version: i64) {
        self.version = Some(version);
    }

    pub fn with_version(mut self, version: i64) -> DeviceTwinInfo {
        self.version = Some(version);
        self
    }

    pub fn version(&self) -> Option<&i64> {
        self.version.as_ref()
    }

    pub fn reset_version(&mut self) {
        self.version = None;
    }

    pub fn set_tags(&mut self, tags: ::std::collections::HashMap<String, Value>) {
        self.tags = Some(tags);
    }

    pub fn with_tags(mut self, tags: ::std::collections::HashMap<String, Value>) -> DeviceTwinInfo {
        self.tags = Some(tags);
        self
    }

    pub fn tags(&self) -> Option<&::std::collections::HashMap<String, Value>> {
        self.tags.as_ref()
    }

    pub fn reset_tags(&mut self) {
        self.tags = None;
    }

    pub fn set_desired_properties(&mut self, desired_properties: ::models::DeviceTwinProperties) {
        self.desired_properties = Some(desired_properties);
    }

    pub fn with_desired_properties(
        mut self,
        desired_properties: ::models::DeviceTwinProperties,
    ) -> DeviceTwinInfo {
        self.desired_properties = Some(desired_properties);
        self
    }

    pub fn desired_properties(&self) -> Option<&::models::DeviceTwinProperties> {
        self.desired_properties.as_ref()
    }

    pub fn reset_desired_properties(&mut self) {
        self.desired_properties = None;
    }

    pub fn set_reported_properties(&mut self, reported_properties: ::models::DeviceTwinProperties) {
        self.reported_properties = Some(reported_properties);
    }

    pub fn with_reported_properties(
        mut self,
        reported_properties: ::models::DeviceTwinProperties,
    ) -> DeviceTwinInfo {
        self.reported_properties = Some(reported_properties);
        self
    }

    pub fn reported_properties(&self) -> Option<&::models::DeviceTwinProperties> {
        self.reported_properties.as_ref()
    }

    pub fn reset_reported_properties(&mut self) {
        self.reported_properties = None;
    }

    pub fn set_provisioning_state(&mut self, provisioning_state: String) {
        self.provisioning_state = Some(provisioning_state);
    }

    pub fn with_provisioning_state(mut self, provisioning_state: String) -> DeviceTwinInfo {
        self.provisioning_state = Some(provisioning_state);
        self
    }

    pub fn provisioning_state(&self) -> Option<&String> {
        self.provisioning_state.as_ref()
    }

    pub fn reset_provisioning_state(&mut self) {
        self.provisioning_state = None;
    }

    pub fn set_module_id(&mut self, module_id: String) {
        self.module_id = Some(module_id);
    }

    pub fn with_module_id(mut self, module_id: String) -> DeviceTwinInfo {
        self.module_id = Some(module_id);
        self
    }

    pub fn module_id(&self) -> Option<&String> {
        self.module_id.as_ref()
    }

    pub fn reset_module_id(&mut self) {
        self.module_id = None;
    }

    pub fn set_configurations(
        &mut self,
        configurations: ::std::collections::HashMap<String, ::models::ConfigurationVersion>,
    ) {
        self.configurations = Some(configurations);
    }

    pub fn with_configurations(
        mut self,
        configurations: ::std::collections::HashMap<String, ::models::ConfigurationVersion>,
    ) -> DeviceTwinInfo {
        self.configurations = Some(configurations);
        self
    }

    pub fn configurations(
        &self,
    ) -> Option<&::std::collections::HashMap<String, ::models::ConfigurationVersion>> {
        self.configurations.as_ref()
    }

    pub fn reset_configurations(&mut self) {
        self.configurations = None;
    }

    pub fn set_capabilities(&mut self, capabilities: ::models::DeviceCapabilities) {
        self.capabilities = Some(capabilities);
    }

    pub fn with_capabilities(
        mut self,
        capabilities: ::models::DeviceCapabilities,
    ) -> DeviceTwinInfo {
        self.capabilities = Some(capabilities);
        self
    }

    pub fn capabilities(&self) -> Option<&::models::DeviceCapabilities> {
        self.capabilities.as_ref()
    }

    pub fn reset_capabilities(&mut self) {
        self.capabilities = None;
    }

    pub fn set_status(&mut self, status: String) {
        self.status = Some(status);
    }

    pub fn with_status(mut self, status: String) -> DeviceTwinInfo {
        self.status = Some(status);
        self
    }

    pub fn status(&self) -> Option<&String> {
        self.status.as_ref()
    }

    pub fn reset_status(&mut self) {
        self.status = None;
    }

    pub fn set_status_reason(&mut self, status_reason: String) {
        self.status_reason = Some(status_reason);
    }

    pub fn with_status_reason(mut self, status_reason: String) -> DeviceTwinInfo {
        self.status_reason = Some(status_reason);
        self
    }

    pub fn status_reason(&self) -> Option<&String> {
        self.status_reason.as_ref()
    }

    pub fn reset_status_reason(&mut self) {
        self.status_reason = None;
    }

    pub fn set_status_updated_time(&mut self, status_updated_time: String) {
        self.status_updated_time = Some(status_updated_time);
    }

    pub fn with_status_updated_time(mut self, status_updated_time: String) -> DeviceTwinInfo {
        self.status_updated_time = Some(status_updated_time);
        self
    }

    pub fn status_updated_time(&self) -> Option<&String> {
        self.status_updated_time.as_ref()
    }

    pub fn reset_status_updated_time(&mut self) {
        self.status_updated_time = None;
    }

    pub fn set_connection_state(&mut self, connection_state: String) {
        self.connection_state = Some(connection_state);
    }

    pub fn with_connection_state(mut self, connection_state: String) -> DeviceTwinInfo {
        self.connection_state = Some(connection_state);
        self
    }

    pub fn connection_state(&self) -> Option<&String> {
        self.connection_state.as_ref()
    }

    pub fn reset_connection_state(&mut self) {
        self.connection_state = None;
    }

    pub fn set_last_activity_time(&mut self, last_activity_time: String) {
        self.last_activity_time = Some(last_activity_time);
    }

    pub fn with_last_activity_time(mut self, last_activity_time: String) -> DeviceTwinInfo {
        self.last_activity_time = Some(last_activity_time);
        self
    }

    pub fn last_activity_time(&self) -> Option<&String> {
        self.last_activity_time.as_ref()
    }

    pub fn reset_last_activity_time(&mut self) {
        self.last_activity_time = None;
    }

    pub fn set_cloud_to_device_message_count(&mut self, cloud_to_device_message_count: i32) {
        self.cloud_to_device_message_count = Some(cloud_to_device_message_count);
    }

    pub fn with_cloud_to_device_message_count(
        mut self,
        cloud_to_device_message_count: i32,
    ) -> DeviceTwinInfo {
        self.cloud_to_device_message_count = Some(cloud_to_device_message_count);
        self
    }

    pub fn cloud_to_device_message_count(&self) -> Option<&i32> {
        self.cloud_to_device_message_count.as_ref()
    }

    pub fn reset_cloud_to_device_message_count(&mut self) {
        self.cloud_to_device_message_count = None;
    }

    pub fn set_authentication_type(&mut self, authentication_type: String) {
        self.authentication_type = Some(authentication_type);
    }

    pub fn with_authentication_type(mut self, authentication_type: String) -> DeviceTwinInfo {
        self.authentication_type = Some(authentication_type);
        self
    }

    pub fn authentication_type(&self) -> Option<&String> {
        self.authentication_type.as_ref()
    }

    pub fn reset_authentication_type(&mut self) {
        self.authentication_type = None;
    }

    pub fn set_x509_thumbprint(&mut self, x509_thumbprint: ::models::X509ThumbprintInfo) {
        self.x509_thumbprint = Some(x509_thumbprint);
    }

    pub fn with_x509_thumbprint(
        mut self,
        x509_thumbprint: ::models::X509ThumbprintInfo,
    ) -> DeviceTwinInfo {
        self.x509_thumbprint = Some(x509_thumbprint);
        self
    }

    pub fn x509_thumbprint(&self) -> Option<&::models::X509ThumbprintInfo> {
        self.x509_thumbprint.as_ref()
    }

    pub fn reset_x509_thumbprint(&mut self) {
        self.x509_thumbprint = None;
    }

    pub fn set_device_e_tag(&mut self, device_e_tag: String) {
        self.device_e_tag = Some(device_e_tag);
    }

    pub fn with_device_e_tag(mut self, device_e_tag: String) -> DeviceTwinInfo {
        self.device_e_tag = Some(device_e_tag);
        self
    }

    pub fn device_e_tag(&self) -> Option<&String> {
        self.device_e_tag.as_ref()
    }

    pub fn reset_device_e_tag(&mut self) {
        self.device_e_tag = None;
    }

    pub fn set_twin_version(&mut self, twin_version: i64) {
        self.twin_version = Some(twin_version);
    }

    pub fn with_twin_version(mut self, twin_version: i64) -> DeviceTwinInfo {
        self.twin_version = Some(twin_version);
        self
    }

    pub fn twin_version(&self) -> Option<&i64> {
        self.twin_version.as_ref()
    }

    pub fn reset_twin_version(&mut self) {
        self.twin_version = None;
    }
}
