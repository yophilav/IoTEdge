#! /bin/bash

###############################################################################
# This script handles the implementation of the various Azure Edge user
# commands. Additionally, this script assists in bootstrapping the
# Azure Edge runtime for docker deployments.
#
# Overall:
# 1) It sets up the filesystem under Edge Home Dir.
# $EDGE_HOME_DIR
#      |-- certs
#      |-- modules
#             |-- __AzureIoTEdgeAgent
#             |-- __AzureIoTEdgeHub
# 2) Generates self signed certs if needed.
# 3) Handles the various user commands to control the Edge
#
# Run this script with --help to learn more.
###############################################################################

set -e

###############################################################################
# Define Script Variables
###############################################################################
SCRIPT_NAME=$(basename $0)
SCRIPT_DIR=$(dirname $0)
SCRIPT_DIR=$(readlink -f ${SCRIPT_DIR})
EDGE_HOME_DIR=
EDGE_CERTS_DIR=
EDGE_MODULES_DIR=
EDGE_AGENT_DIR=
EDGE_HUB_DIR=

# self signed cert configs
EDGE_USE_SELF_SIGNED_CERTS=ON
EDGE_FORCE_GEN_CERTS=OFF
EDGE_SUPPORTED_HOST_OS=
EDGE_AGENT_DIR_NAME="__AzureIoTEdgeAgent"
EDGE_HUB_DIR_NAME="__AzureIoTEdgeHub"
EDGE_HUB_SERVER_CERT_NAME="azure-iot-edge.hub.server.cert.pfx"
EDGE_DEVICE_CA_CERT_NAME="azure-iot-edge.chain.ca.pem.crt"
EDGE_HUB_SERVER_DNS_NAME=
EDGE_DEVICE_CA_CERT_USR=
EDGE_HUB_SERVER_CERT_USR=

EDGE_AGENT_LABEL="net.azure-devices.edge.owner=Microsoft.Azure.Devices.Edge.Agent"
EDGE_RUNTIME_CONTAINER_NAME="edgeAgent"
EDGE_RUNTIME_NETWORK_ID="azure-iot-edge"
EDGE_RUNTIME_COMMANDS=("start" "stop" "restart" "status" "uninstall")
EDGE_RUNTIME_COMMAND=
EDGE_RUNTIME_IMG=
EDGE_RUNTIME_REPOSITORY_CSV=
EDGE_RUNTIME_LOG_LEVEL=
EDGE_MODULE_REPOSITORIES_CSV=

# iothub conecction details
IOTHUB_DEVICE_CONNECTION_STRING=
IOTHUB_HOSTNAME=
IOTHUB_DEVICE_ID=
IOTHUB_SHARED_KEY=

# docker settings
DOCKER_URI=
DOCKER_PROTOCOL=
DOCKER_ENDPOINT=
DOCKER_PORT=
DOCKER_LOG_DRIVER=
DOCKER_LOG_OPTIONS_CSV=
DOCKER_CMD_RESULT=
DOCKER_CMD_OUTPUT=
EDGE_CONTAINER_REPO_ADDRESS=
EDGE_CONTAINER_REPO_USERNAME=
EDGE_CONTAINER_REPO_PASSWORD=

# general script variables
CSV_SEP=":"
LOG_LEVEL_ERR=1
LOG_LEVEL_INF=2
LOG_LEVEL_DBG=3
VERBOSE_LEVEL_DEFAULT=$LOG_LEVEL_ERR
VERBOSE_LEVEL=$VERBOSE_LEVEL_DEFAULT
DRY_RUN_MODE=OFF
PARSED_REPO_RESULT=
PARSED_REPO_ADDRESS=
PARSED_REPO_USERNAME=
PARSED_REPO_PASSWORD=
PARSED_DOCKER_IMAGE_RESULT=
PARSED_DOCKER_IMAGE_REPO_ADDRESS=
PARSED_DOCKER_IMAGE_NAME=
PARSED_DOCKER_IMAGE_TAG=
declare -a PARSED_EDGE_MODULES_REPO_ENV

###############################################################################
# Print usage information pertaining to this script and exit
###############################################################################
function usage()
{
    echo ""
    echo "$SCRIPT_NAME [command] [options]"
    echo ""
    echo " Supported Edge Runtime Commands: ${EDGE_RUNTIME_COMMANDS[@]}"
    echo " start | restart"
    echo "   -d,   --edge-home-dir        Azure Edge Home Directory. Required."
    echo "   -c,   --connection-string    Azure IoT Hub Device Connection" \
         "string. Required."
    echo "                                Format:" \
         "HostName=<>;DeviceId=<>;SharedAccessKey=<>."
    echo "   -dns --edge-hub-dns          Edge Hub FQDN hostname. Required."
    echo "                                If not provided, users will be" \
         "prompted to enter a value."
    echo "   --docker-uri                 Local Docker Daemon URI. Required."
    echo "   --docker-log-driver          Docker log driver setting." \
         "If unspecified Docker defaults will be chosen."
    echo "   --docker-log-options-csv     Docker log options, expressed as." \
         "\"key\",\"value\" pairs."
    echo "                                Multiple options should be" \
         "seperated by ${CSV_SEP}"
    echo "                                If unspecified, Docker defaults" \
         "will be used."
    echo "   -img, --edge-runtime-image   Azure Edge Runtime Image. Required."
    echo "                                Format: repository/image:tag."
    echo "   --module-repositories-csv    Azure Edge Modules Container" \
         "Repositories. Optional."
    echo "                                CSV expressed as" \
         "\"address\",\"username\",\"password\"."
    echo "                                Multiple repositories should be" \
         "seperated by ${CSV_SEP}"
    echo "                                If a username and password are not" \
         "required, pass in \"\"."
    echo "   --edge-log-level             Azure Edge runtime log level." \
         "Optional. Supported values info, debug."
    echo "   --force-regenerate-certs     Force re-generation of self signed" \
         "certificates even if they already exist."
    echo "   --edge-device-ca-cert        User supplied Device CA" \
         "certificate. Optional."
    echo "                                Use this as an alternative to" \
         "self signed certificates."
    echo "   --edge-hub-server-cert       User supplied Edge Hub server" \
         "certificate. Optional."
    echo "                                Use this as an alternative to" \
         "self signed certificates."
    echo ""
    echo " stop"
    echo ""
    echo " status"
    echo ""
    echo " uninstall"
    echo ""
    echo " -v,   --verbose                Global verbose level. Optional." \
         "${LOG_LEVEL_ERR} - Error, ${LOG_LEVEL_INF} - Info, " \
         "${LOG_LEVEL_DBG} - Debug."
    echo "Default Level - ${VERBOSE_LEVEL_DEFAULT}"
    exit 1;
}

function print_help_and_exit()
{
    echo "Run $SCRIPT_NAME --help for more information."
    exit 1
}

function print_unhandled_args_and_exit()
{
    echo "Unknown Input Argument(s): $@"
    echo "Run $SCRIPT_NAME --help for more information."
    exit 1
}

###############################################################################
# Log message to console depending on verbosity level setting
###############################################################################
function log()
{
    if [[ ${VERBOSE_LEVEL} -ge ${1} ]]; then
        shift;
        echo "$@"
    fi
}

function log_debug()
{
    log ${LOG_LEVEL_DBG} "DBG:$@"
}

function log_error()
{
    log ${LOG_LEVEL_ERR} "ERR:$@"
}

function log_info()
{
    log ${LOG_LEVEL_INF} "INF:$@"
}

###############################################################################
# Print prerequisite information and exit
###############################################################################
function print_required_prerequisites_and_exit()
{
    echo ""
    echo "Azure Edge Runtime Prerequisites:"
    echo " - OpenSSL should be installed if using self signed certificates."
    echo " - Docker should be installed and be up and running."
    echo " - User should be part of 'docker' user group OR" \
         "   be able run this script using sudo."
    echo " - User should be able to install CA certificates on this machine."
    exit 1
}

###############################################################################
# Validate and parse the IoTHub Connection String. Exit if invalid.
# Input: Connection string to validate
#
# Ouput
# Globals updated:
#   IOTHUB_HOSTNAME
#   IOTHUB_DEVICE_ID
#   IOTHUB_SHARED_KEY
###############################################################################
function validate_and_parse_connection_string()
{
    local cs="${1}"
    # remove any leading and trailing quotes
    cs="${cs%\"}"
    cs="${cs#\"}"
    local grep_regex='^[[:space:]]*HostName=[[:graph:]]\+;DeviceId=[[:graph:]]\+;SharedAccessKey=[[:graph:]]\+$'

    if ! $(echo "${cs}" | grep -q ${grep_regex}); then
        log_error "Device Connection String has an Invalid Format: ${cs}"
        print_help_and_exit
    fi

    IOTHUB_HOSTNAME=$( echo "${cs}" | sed 's|^[[:space:]]*HostName=\([[:graph:]]\+\);DeviceId=\([[:graph:]]\+\);SharedAccessKey=\([[:graph:]]\+\)$|\1|')
    IOTHUB_DEVICE_ID=$( echo "${cs}" | sed 's|^[[:space:]]*HostName=\([[:graph:]]\+\);DeviceId=\([[:graph:]]\+\);SharedAccessKey=\([[:graph:]]\+\)$|\2|')
    IOTHUB_SHARED_KEY=$( echo "${cs}" | sed 's|^[[:space:]]*HostName=\([[:graph:]]\+\);DeviceId=\([[:graph:]]\+\);SharedAccessKey=\([[:graph:]]\+\)$|\3|')

    log_debug "  Connection String Hostname  : ${IOTHUB_HOSTNAME}"
    log_debug "  Connection String Device Id : ${IOTHUB_DEVICE_ID}"
    log_debug "  Connection String Shared Key: ${IOTHUB_SHARED_KEY}"
}

###############################################################################
# Validate and parse the Docker URI. Exit if invalid.
# Input: URI to validate
#
# Ouput
# Globals updated:
#   DOCKER_PROTOCOL -- http:// or https:// or unix://
#   DOCKER_ENDPOINT -- Used for volume mounting Unix sockets
#   DOCKER_PORT     -- Valid when http or https is used
###############################################################################
function validate_and_parse_docker_uri()
{
    local uri="${1}"
    local grep_regex='^[[:space:]]*[[:lower:]]\+:\/\/[[:graph:]]\+$'
    if ! $(echo "${uri}" | grep -q ${grep_regex}); then
        log_error "Docker URI Format Is Invalid: ${uri}"
        print_help_and_exit
    fi

    DOCKER_PROTOCOL=$( echo "${uri}" | sed 's|^[[:space:]]*\([[:lower:]]\+:\)\/\/\([[:graph:]]\+\)\(:[[:digit:]]\+\)\?$|\1|' )
    grep_regex='^\(unix\|http[s]\?\):$'
    if ! $(echo "${DOCKER_PROTOCOL}" | grep -q ${grep_regex}); then
        log_error "Docker URI Protocol Is Unsupported: ${uri}"
        print_help_and_exit
    fi
    if [[ "${DOCKER_PROTOCOL}" == "http"* ]]; then
        DOCKER_ENDPOINT=$( echo "${uri}" | sed 's|^[[:space:]]*\([[:lower:]]\+:\)\/\/\([[:graph:]]\+\)\(:[[:digit:]]\+\)$|\2|' )
        DOCKER_PORT=$( echo "${uri}" | sed 's|^[[:space:]]*\([[:lower:]]\+:\)\/\/\([[:graph:]]\+\):\([[:digit:]]\+\)$|\3|' )
    else
        DOCKER_ENDPOINT=$( echo "${uri}" | sed 's|^[[:space:]]*\([[:lower:]]\+:\)\/\/\([[:graph:]]\+\)$|\2|' )
    fi

    log_debug "Docker URI Protocol: '${DOCKER_PROTOCOL}'"
    log_debug "Docker URI Endpoint: '${DOCKER_ENDPOINT}'"
    log_debug "Docker URI Port:     '${DOCKER_PORT}'"
}

###############################################################################
# Helper function to validate a docker repo address, username and password CSV
#
# Input:
#   A single CSV to be checked
#
# Ouput
# Globals updated:
#   PARSED_REPO_RESULT 0 -- Success, 1 -- otherwise
#   PARSED_REPO_ADDRESS
#   PARSED_REPO_USERNAME
#   PARSED_REPO_PASSWORD
###############################################################################
function validate_and_parse_repository()
{
    local csv_str="${1}"
    local result=1

    PARSED_REPO_RESULT=
    PARSED_REPO_ADDRESS=
    PARSED_REPO_USERNAME=
    PARSED_REPO_PASSWORD=
    address=$(echo ${csv_str} | cut -d, -f1)
    username=$(echo ${csv_str} | cut -d, -f2)
    password=$(echo ${csv_str} | cut -d, -f3)
    # trim trailing and leading " quote characters respectively
    address="${address%\"}"
    address="${address#\"}"
    username="${username%\"}"
    username="${username#\"}"
    password="${password%\"}"
    password="${password#\"}"
    PARSED_REPO_ADDRESS="${address}"
    PARSED_REPO_USERNAME="${username}"
    PARSED_REPO_PASSWORD="${password}"
    if [[ ! -z "${PARSED_REPO_ADDRESS}" ]] &&
       [[ "${address}" != "null" ]] &&
       [[ "${username}" != "null" ]] &&
       [[ "${password}" != "null" ]]; then
        result=0
    fi

    PARSED_REPO_RESULT=${result}
    log_debug "Repo Address: ${PARSED_REPO_ADDRESS}"
    log_debug "Repo Username: ${PARSED_REPO_USERNAME}"
    log_debug "Repo Password: ${PARSED_REPO_PASSWORD}"
}

###############################################################################
# Helper function to validate and parse a docker image
#
# Input:
#   A single docker image string to be checked
#
# Ouput
# Globals updated:
#   PARSED_DOCKER_IMAGE_RESULT 0 -- Success, 1 -- otherwise
#   PARSED_DOCKER_IMAGE_REPO_ADDRESS
#   PARSED_DOCKER_IMAGE_NAME
#   PARSED_DOCKER_IMAGE_TAG
###############################################################################
function validate_and_parse_docker_image()
{
    local img="${1}"

    PARSED_DOCKER_IMAGE_RESULT=
    PARSED_DOCKER_IMAGE_REPO_ADDRESS=
    PARSED_DOCKER_IMAGE_NAME=
    PARSED_DOCKER_IMAGE_TAG=
    local grep_regex='^[[:space:]]*[[:graph:]]\+\/[[:graph:]]\+:[[:alnum:]]\+$'
    if ! $(echo "${img}" | grep -q ${grep_regex}); then
        log_dbg "Docker Image Is Inconsistent: ${img}"
        PARSED_DOCKER_IMAGE_RESULT=1
    else
        local result=
        result=$( echo "${img}" | sed 's|^[[:space:]]*\([[:graph:]]\+\/\)\([[:graph:]]\+\)\(:[[:alnum:]]\+\)\?$|\1|' )
        # trim trailing '/' character
        result="${result%\/}"
        PARSED_DOCKER_IMAGE_REPO_ADDRESS="${result}"
        result=$( echo "${img}" | sed 's|^[[:space:]]*\([[:graph:]]\+\/\)\([[:graph:]]\+\)\(:[[:alnum:]]\+\)\?$|\2|' )
        PARSED_DOCKER_IMAGE_NAME="${result}"
        result=$( echo "${img}" | sed 's|^[[:space:]]*\([[:graph:]]\+\/\)\([[:graph:]]\+\)\(:[[:alnum:]]\+\)\?$|\3|' )
        result="${result#\:}"
        PARSED_DOCKER_IMAGE_TAG="${result}"
        PARSED_DOCKER_IMAGE_RESULT=0
    fi
}

###############################################################################
# Helper function to determine first match of the Edge runtime image repository
#
# Input:
#   Repositories CSV
#   Docker image string
#   Docker image repository address to be matched
#
# Ouput
# Globals updated:
#   EDGE_CONTAINER_REPO_ADDRESS
#   EDGE_CONTAINER_REPO_USERNAME
#   EDGE_CONTAINER_REPO_PASSWORD
#
# Note: If no repository match is found, it implies that the image could be
# downloaded without any credentials.
###############################################################################
function obtain_edge_runtime_repository_credentials()
{
    local repos_csv="${1}"
    local image="${2}"
    local image_repo_address="${3}"
    local index=0

    if [[ ! -z "${repos_csv}" ]]; then
        OIFS=$IFS
        IFS=${CSV_SEP}
        for repo in ${repos_csv}; do
            validate_and_parse_repository "${repo}"
            if [[ "${PARSED_REPO_RESULT}" == "0" ]]; then
                log_debug "Module Repo [${index}] Address: [${PARSED_REPO_ADDRESS}]"
                log_debug "Module Repo [${index}] Username: [${PARSED_REPO_USERNAME}]"
                log_debug "Module Repo [${index}] Password: [${PARSED_REPO_PASSWORD}]"
                if [[ "${PARSED_REPO_ADDRESS}" == "${image_repo_address}" ]]; then
                    log_debug "Matched Edge Image ${image} To Repo:${PARSED_REPO_ADDRESS}"
                    EDGE_CONTAINER_REPO_ADDRESS="${PARSED_REPO_ADDRESS}"
                    EDGE_CONTAINER_REPO_USERNAME="${PARSED_REPO_USERNAME}"
                    EDGE_CONTAINER_REPO_PASSWORD="${PARSED_REPO_PASSWORD}"
                fi
                index=$((index+1))
            fi
        done
        IFS=$OIFS
    fi
}

###############################################################################
# Obtain and validate the command line options supported by this script
###############################################################################
function process_args()
{
    local save_next_arg=0

    for arg in "$@"
    do
        if [ ${save_next_arg} -eq 1 ]; then
            EDGE_HOME_DIR="$arg"
            save_next_arg=0
        elif [ ${save_next_arg} -eq 2 ]; then
            IOTHUB_DEVICE_CONNECTION_STRING="$arg"
            save_next_arg=0
        elif [ ${save_next_arg} -eq 3 ]; then
            DOCKER_URI="$arg"
            save_next_arg=0
        elif [ ${save_next_arg} -eq 4 ]; then
            DOCKER_LOG_DRIVER="$arg"
            save_next_arg=0
        elif [ ${save_next_arg} -eq 5 ]; then
            DOCKER_LOG_OPTIONS_CSV="$arg"
            save_next_arg=0
        elif [ ${save_next_arg} -eq 6 ]; then
            EDGE_RUNTIME_IMG="$arg"
            save_next_arg=0
        elif [ ${save_next_arg} -eq 7 ]; then
            EDGE_RUNTIME_REPOSITORY_CSV="$arg"
            save_next_arg=0
        elif [ ${save_next_arg} -eq 8 ]; then
            EDGE_MODULE_REPOSITORIES_CSV="$arg"
            save_next_arg=0
        elif [ ${save_next_arg} -eq 9 ]; then
            EDGE_RUNTIME_LOG_LEVEL="$arg"
            save_next_arg=0
        elif [ ${save_next_arg} -eq 10 ]; then
            EDGE_HUB_SERVER_DNS_NAME="$arg"
            save_next_arg=0
        elif [ ${save_next_arg} -eq 11 ]; then
            EDGE_DEVICE_CA_CERT_USR="$arg"
            save_next_arg=0
        elif [ ${save_next_arg} -eq 12 ]; then
            EDGE_HUB_SERVER_CERT_USR="$arg"
            save_next_arg=0
        elif [ ${save_next_arg} -eq 13 ]; then
            VERBOSE_LEVEL=$arg
            save_next_arg=0
        else
            case "${arg}" in
                "-h" | "--help" ) usage;;
                "start" )   EDGE_RUNTIME_COMMAND="${arg}";;
                "restart" ) EDGE_RUNTIME_COMMAND="${arg}";;
                "stop" )    EDGE_RUNTIME_COMMAND="${arg}";;
                "status" )  EDGE_RUNTIME_COMMAND="${arg}";;
                "uninstall" )  EDGE_RUNTIME_COMMAND="${arg}";;
                "-d" | "--edge-home-dir" ) save_next_arg=1;;
                "-c" | "--connection-string" ) save_next_arg=2;;
                "--docker-uri" ) save_next_arg=3;;
                "--docker-log-driver" ) save_next_arg=4;;
                "--docker-log-options-csv" ) save_next_arg=5;;
                "-img" | "--edge-runtime-image" ) save_next_arg=6;;
                "-r" | "--edge-repository-csv" ) save_next_arg=7;;
                "--module-repositories-csv" ) save_next_arg=8;;
                "--edge-log-level" ) save_next_arg=9;;
                "-dns" | "--edge-hub-dns" ) save_next_arg=10;;
                "--edge-device-ca-cert" ) save_next_arg=11;;
                "--edge-hub-server-cert" ) save_next_arg=12;;
                "-v" | "--verbose" ) save_next_arg=13;;
                "--force-regenerate-certs" ) EDGE_FORCE_GEN_CERTS=ON;;
                "-n" | "--dry-run" ) DRY_RUN_MODE=ON;;
                * ) print_unhandled_args_and_exit ${arg};;
            esac
        fi
    done

    if [[ -z "${EDGE_RUNTIME_COMMAND}" ]]; then
        log_error "Edge Runtime Command Cannot Be Empty."
        print_help_and_exit
    else
        local cmd_valid=0
        for cmd in "${EDGE_RUNTIME_COMMANDS[@]}"
        do
            if [[ "${cmd}" == "${EDGE_RUNTIME_COMMAND}" ]]; then
                cmd_valid=1
            fi
        done
        if [[ $cmd_valid -eq 0 ]]; then
            log_error "Edge Runtime Command Invalid: ${cmd}"
            print_help_and_exit
        fi
    fi

    local usr_ca_cert=0
    local usr_server_cert=0
    [[ -z "${EDGE_DEVICE_CA_CERT_USR}" ]] || usr_ca_cert=1
    [[ -z "${EDGE_HUB_SERVER_CERT_USR}" ]] || usr_server_cert=1
    local usr_xor=$usr_ca_cert^$usr_server_cert
    if [[ $usr_xor -eq 0 ]]; then
        [[ $usr_ca_cert -eq 0 ]] || EDGE_USE_SELF_SIGNED_CERTS=OFF
    else
        log_error "Both CA and Edge Runtime Server Cert must be specified." \
                  "Alternatively, users can use self signed certificates."
        print_help_and_exit
    fi

    if [[ $EDGE_USE_SELF_SIGNED_CERTS == OFF ]]; then
        if [[ ! -e "${EDGE_DEVICE_CA_CERT_USR}" ]]; then
            log_error "Device CA certificate does not exist."
            print_help_and_exit
        fi
        if [[ ! -e "${EDGE_DEVICE_CA_CERT_USR}" ]]; then
            log_error "Edge Server certificate does not exist."
            print_help_and_exit
        fi
    fi

    if [[ "${EDGE_RUNTIME_COMMAND}" == *"start" ]]; then
        if [[ -z "${EDGE_HOME_DIR}" ]]; then
            log_error "Edge Home Directory Cannot Be Empty."
            print_help_and_exit
        else
            EDGE_HOME_DIR=$(readlink -f ${EDGE_HOME_DIR})
            if [[ ! -d "${EDGE_HOME_DIR}" ]]; then
                log_error "Edge Home Directory Is Invalid: ${EDGE_HOME_DIR}"
                print_help_and_exit
            fi
        fi

        if [[ -z "${EDGE_RUNTIME_IMG}" ]]; then
            log_error "Supplied Edge Runtime Image Is Empty."
            print_help_and_exit
        else
            validate_and_parse_docker_image "${EDGE_RUNTIME_IMG}"
            if [[ ${PARSED_DOCKER_IMAGE_RESULT} -ne 0 ]]; then
                log_error "Edge Docker Image Format Is Invalid: ${EDGE_RUNTIME_IMG}"
                print_help_and_exit
            fi
        fi
        obtain_edge_runtime_repository_credentials "${EDGE_MODULE_REPOSITORIES_CSV}" \
                                                   "${EDGE_RUNTIME_IMG}" \
                                                   "${PARSED_DOCKER_IMAGE_REPO_ADDRESS}"

        if [[ -z "${DOCKER_URI}" ]]; then
            DOCKER_URI="unix:///var/run/docker.sock"
            DOCKER_ENDPOINT="/var/run/docker.sock"
            DOCKER_PROTOCOL="unix://"
            DOCKER_PORT=""
        else
            validate_and_parse_docker_uri "${DOCKER_URI}"
        fi

        if [[ -z "${IOTHUB_DEVICE_CONNECTION_STRING}" ]]; then
            log_error "Supplied Device Connection String Is Empty."
            print_help_and_exit
        fi
        validate_and_parse_connection_string "${IOTHUB_DEVICE_CONNECTION_STRING}"
    fi

    EDGE_CERTS_DIR="${EDGE_HOME_DIR}/certs"
    EDGE_MODULES_DIR="${EDGE_HOME_DIR}/modules"
    EDGE_AGENT_DIR="${EDGE_MODULES_DIR}/${EDGE_AGENT_DIR_NAME}"
    EDGE_HUB_DIR="${EDGE_MODULES_DIR}/${EDGE_HUB_DIR_NAME}"
}

###############################################################################
# Helper function to check if an application is installed. If not found
# the routine exits.
###############################################################################
function check_if_installed()
{
    local app="${1}"
    log_info "Checking ${app} Installation."
    $(command -v ${app} >/dev/null 2>&1 ||
    { echo >&2 "Error: ${app} not found. Please install ${app}. Aborting."; exit 1;})
    log_info "   ${app}... Ok."
}

###############################################################################
# Verify Azure Edge Runtime Dependencies; If not found, print diagnostic and
# exit.
###############################################################################
function verify_prerequisites()
{
    local return_val
    local cmd="${1}"
    local cert_opt="${2}"

    log_info  "***************************************************************"
    log_info  "Verifying Prerequisites..."

    if [[ "${cmd}" == *"start" ]] && [[ "${cert_opt}" == "ON" ]]; then
        check_if_installed "openssl"
    fi
    check_if_installed "docker"

    log_info "Checking Docker Daemon State."
    return_val=$(systemctl show --property ActiveState docker)
    if [[ "${return_val}" != *"=active" ]]; then
        log_error "Docker Daemon is unavailable or not installed. Aborting."
        print_required_prerequisites_and_exit
    fi
    log_info "   Docker Daemon... Ok."

    log_info "Checking User Permissions."
    return_val=$(docker ps)
    if [[ "${return_val}" == *"permission denied"* ]]; then
        log_error "User lacks permissions to launch docker commands. Aborting."
        print_required_prerequisites_and_exit
    fi
    log_info "   Docker Permissions... Ok."

    log_info "Done Verifying Prerequisites!"
    log_info "****************************************************************"
}

###############################################################################
# Create Module Filesystem on the host
###############################################################################
function prepare_modules_filesystem()
{
    if [[ $DRY_RUN_MODE == OFF ]]; then
        mkdir -p "${EDGE_MODULES_DIR}"
        mkdir -p "${EDGE_AGENT_DIR}"
        mkdir -p "${EDGE_HUB_DIR}"
    fi
}

###############################################################################
# Generate required self signed certs
###############################################################################
function generate_self_signed_certs_if_needed()
{
    local gen_certs=0
    local cert_file=

    ca_cert_file="${EDGE_AGENT_DIR}/${EDGE_DEVICE_CA_CERT_NAME}"
    hub_cert_file="${EDGE_AGENT_DIR}/${EDGE_HUB_SERVER_CERT_NAME}"

    log_info ""
    log_info "****************************************************************"
    log_info "Checking Edge Runtime Certificates..."

    if [[ $EDGE_FORCE_GEN_CERTS == ON ]]; then
        log_info "  Forced Regeneration of Self Signed Certificates Requested."
        gen_certs=1
    else
        log_info "  Checking if ${ca_cert_file} exists..."
        if [[ ! -f "${ca_cert_file}" ]]; then
            log_error "${ca_cert_file} does not exist."
            gen_certs=1
        else
            log_info "      Ok."
            log_info "  Checking if ${hub_cert_file} exists..."
            if [[ ! -f "${hub_cert_file}" ]]; then
                log_info "  ${hub_cert_file} does not exist."
                gen_certs=1
            else
                log_info "      Ok."
                log_info "Edge Runtime Certificates Check Complete."
                log_info "No certificate generation required."
            fi
        fi
    fi

    if [[ $gen_certs -eq 1 ]]; then
        # Obtain hostname of this device and use it to bootstrap the hub
        if [[ -z "${EDGE_HUB_SERVER_DNS_NAME}" ]]; then
            local loop_done=0
            echo ""
            local host_name=$(hostname -A | cut -d' ' -f1)
            while [[ $loop_done -eq 0 ]]; do
                echo "Enter the Fully qualified DNS Name (FQDN) of the" \
                     "Edge Device (ex. myserver.mydomain.com)." \
                     "Press Enter for default [${host_name}]:"
                read arg
                [[ ! -z ${arg} ]] || arg=${host_name}
                if [[ -z ${arg} ]]; then
                    echo ""
                    echo "Please Enter a valid DNS Name (FQDN)."
                else
                    EDGE_HUB_SERVER_DNS_NAME="${arg}"
                    loop_done=1
                fi
            done
        fi
        log_info "   Creating self signed Certificates..."
        if [[ ! -d "${EDGE_CERTS_DIR}" ]]; then
            log_info "   Edge Certificate Directory does not exist." \
                 "Creating: ${EDGE_CERTS_DIR}"
            mkdir "${EDGE_CERTS_DIR}"
        fi

        declare -a cmd_args
        cmd_args+=("--edge-certs-dir" "${EDGE_CERTS_DIR}")
        cmd_args+=("--edge-hub-dns" "${EDGE_HUB_SERVER_DNS_NAME}")
        cmd_args+=("${repository}")
        local cmd="${SCRIPT_DIR}/../gen-certs/generate-certs ${cmd_args[@]}"
        if [[ $DRY_RUN_MODE == OFF ]]; then
            ${cmd}
            [ $? -eq 0 ] || exit $?
            cp -r "${EDGE_CERTS_DIR}/output"/* "${EDGE_AGENT_DIR}"
        else
            echo "${cmd}"
        fi
    fi
    log_info "****************************************************************"
}

###############################################################################
# Obtain the status of the edge runtime container
#
# Output
# Returns the following status values
#   EDGE_RUNNING - Edge Runtime is running
#   EDGE_STOPPED - Edge Runtime is stopped
#   EDGE_RESTARTING - Edge Runtime is in the process of restarting
#   EDGE_UNAVAILABLE - Edge Runtime is not installed on this device
###############################################################################
function get_status_edge_runtime()
{
    local name="${EDGE_RUNTIME_CONTAINER_NAME}"

    is_running=$(docker inspect --format="{{.State.Running}}" "${name}" 2> /dev/null)
    if [[ $? -ne 0 ]]; then
        result="EDGE_UNAVAILABLE"
    else
        local result=
        if [[ "${is_running}" == "true" ]]; then
            result="EDGE_RUNNING"
        else
            result="EDGE_STOPPED"
            local is_restarting=$(docker inspect --format="{{.State.Restarting}}" "${name}")
            if [[ "${is_restarting}" == "true" ]]; then
                result="EDGE_RESTARTING"
            fi
        fi
    fi

    echo "${result}"
}

###############################################################################
# Prints out the status of the edge runtime container
###############################################################################
function print_status_edge_runtime()
{
    local status=$(get_status_edge_runtime 2> /dev/null)
    echo "Edge Runtime Status: ${status}"
}

###############################################################################
# Implementation of the Docker login command
#
# Input:
#   Repository Address
#   Repository Username
#   Repository Password
#
# Return Ouput: None
# Globals Updated:
#   DOCKER_CMD_RESULT  0 -- Success, 1 -- Error
###############################################################################
function docker_command_login()
{
    local repository="${1}"
    local username="${2}"
    local password="${3}"
    local cmd=

    if [[ ! -z "${repository}" ]] && [[ ! -z "${username}" ]]; then
        log_debug "Attempting to Login Into Repository: ${repository}"
        declare -a cmd_args
        cmd_args+=("--username" "${username}")
        cmd_args+=("--password" "${password}")
        cmd_args+=("${repository}")

        if [[ $DRY_RUN_MODE == OFF ]]; then
            local result=$(docker login "${cmd_args[@]}")
            [ $? -eq 0 ] || exit $?
        else
            local cmd="docker login ${cmd_args[@]}"
            echo "${cmd}"
        fi
    fi
    DOCKER_CMD_OUTPUT=
    DOCKER_CMD_RESULT=0
}


###############################################################################
# Implementation of the Docker pull command
#
# Input:
#   Image name
#
# Return Ouput: None
# Globals Updated:
#   DOCKER_CMD_RESULT  0 -- Success, 1 -- Error
#   DOCKER_CMD_OUTPUT  "updated" if a new image was pulled
#                      "current" if the local image is current
###############################################################################
function docker_command_pull()
{
    local image="${1}"
    local cmd=

    log_debug "Attempting to Pull Edge Runtime Image: ${image}"
    DOCKER_CMD_OUTPUT=
    if [[ $DRY_RUN_MODE == OFF ]]; then
        local pull_result=$(docker pull "${image}")
        echo "Pull Result:[${pull_result}]"
        [ $? -eq 0 ] || exit $?
        local grep_regex=".*Status:[[:space:]]\+Image[[:space:]]is[[:space:]]up[[:space:]]to[[:space:]]date"
        if ! $(echo "${pull_result}" | grep -q ${grep_regex}); then
            DOCKER_CMD_OUTPUT="updated"
            log_debug "Image Updated For: ${image}"
        else
            DOCKER_CMD_OUTPUT="current"
            log_debug "Image Is Current For: ${image}"
        fi
    else
        local cmd="docker pull ${image}"
        echo "${cmd}"
    fi

    DOCKER_CMD_RESULT=0
}

###############################################################################
# Implementation of the Docker start command
#
# Input:
#   Container name
#
# Return Ouput: None
# Globals Updated:
#   DOCKER_CMD_RESULT  0 -- Success, 1 -- Error
###############################################################################
function docker_command_start_container()
{
    local container_name="${1}"
    local cmd=

    log_debug "Attempting to Start Container: ${container_name}"
    if [[ $DRY_RUN_MODE == OFF ]]; then
        local result=$(docker start "${container_name}")
        [ $? -eq 0 ] || exit $?
    else
        local cmd="docker start ${container_name}"
        echo "${cmd}"
    fi

    DOCKER_CMD_OUTPUT=
    DOCKER_CMD_RESULT=0
}

###############################################################################
# Implementation of the Docker stop command
#
# Input:
#   Container name
#
# Return Ouput: None
# Globals Updated:
#   DOCKER_CMD_RESULT  0 -- Success, 1 -- Error
###############################################################################
function docker_command_stop_container()
{
    local container_name="${1}"
    local cmd=

    log_debug "Attempting to Stop Container: ${container_name}"
    if [[ $DRY_RUN_MODE == OFF ]]; then
        local result=$(docker stop "${container_name}")
        [ $? -eq 0 ] || exit $?
    else
        local cmd="docker stop ${container_name}"
        echo "${cmd}"
    fi

    DOCKER_CMD_OUTPUT=
    DOCKER_CMD_RESULT=0
}

###############################################################################
# Implementation of the multi container docker stop command by label
#
# Input:
#   Label name
#
# Return Ouput: None
# Globals Updated:
#   DOCKER_CMD_RESULT  0 -- Success, 1 -- Error
###############################################################################
function docker_command_stop_by_label()
{
    local label_name="${1}"
    local cmd=

    log_debug "Attempting to Stop Containers With Label: ${label_name}"
    if [[ $DRY_RUN_MODE == OFF ]]; then
        local ids=$(sudo docker ps -a --filter "label=${label_name}" --format "{{.ID}}")
        if [[ ! -z "${ids}" ]]; then
            local result=$(docker stop ${ids})
            [ $? -eq 0 ] || exit $?
        fi
    else
        local cmd="docker stop $(sudo docker ps -a --filter "label=${label_name}" --format "{{.ID}}")"
        echo "${cmd}"
    fi

    DOCKER_CMD_OUTPUT=
    DOCKER_CMD_RESULT=0
}

###############################################################################
# Implementation of the Docker rm command
#
# Input:
#   Container name
#
# Return Ouput: None
# Globals Updated:
#   DOCKER_CMD_RESULT  0 -- Success, 1 -- Error
###############################################################################
function docker_command_remove_container()
{
    local container_name="${1}"
    local status=$(get_status_edge_runtime 2> /dev/null)
    if [[ "${status}" != "EDGE_UNAVAILABLE" ]]; then
        log_debug "Attempting Removal of Edge Runtime Container:${container_name}"
        if [[ $DRY_RUN_MODE == OFF ]]; then
            local result=$(docker rm "${container_name}")
            [ $? -eq 0 ] || exit $?
        else
            local cmd="docker rm ${container_name}"
            echo "${cmd}"
        fi
    fi

    DOCKER_CMD_OUTPUT=
    DOCKER_CMD_RESULT=0
}

###############################################################################
# Implementation of the multi container docker rm command by label
#
# Input:
#   Label name
#
# Return Ouput: None
# Globals Updated:
#   DOCKER_CMD_RESULT  0 -- Success, 1 -- Error
###############################################################################
function docker_command_remove_by_label()
{
    local label_name="${1}"
    local cmd=

    log_debug "Attempting to Remove Containers With Label: ${label_name}"
    if [[ $DRY_RUN_MODE == OFF ]]; then
        local ids=$(sudo docker ps -a --filter "label=${label_name}" --format "{{.ID}}")
        if [[ ! -z "${ids}" ]]; then
            local result=$(docker rm ${ids})
            [ $? -eq 0 ] || exit $?
        fi
    else
        local cmd="docker rm $(sudo docker ps -a --filter "label=${label_name}" --format "{{.ID}}")"
        echo "${cmd}"
    fi

    DOCKER_CMD_OUTPUT=
    DOCKER_CMD_RESULT=0
}

###############################################################################
# Implementation of the Docker Network create command
# This routine detects if the a network is availble and if not create it
#
# Input:
#   Network name
#
# Return Ouput: None
# Globals Updated:
#   DOCKER_CMD_RESULT  0 -- Success, 1 -- Error
###############################################################################
function docker_command_create_network()
{
    local nw_name="${1}"
    log_debug "Checking if Docker Network '${nw_name}' Already Exists"
    local is_created=$(docker network ls -q --filter name="${nw_name}")
    #is_created=$(docker network inspect --format="{{.Id}}" ${nw_name} >/dev/null)
    if [[ -z "${is_created}" ]]; then
        log_info "Creating Docker Network ${nw_name}"
        result=$(docker network create --driver bridge "${nw_name}")
    else
        log_debug "Docker Network '${nw_name}' Already Exists"
    fi
    DOCKER_CMD_OUTPUT=
    DOCKER_CMD_RESULT=0
}

###############################################################################
# Implementation to parse a CSV containing modules repository address and
# credentials and build out the docker run environment args
# Return Ouput: None
# Globals Updated:
#   PARSED_EDGE_MODULES_REPO_ENV  -- Contains the EdgeAgent env variables
#                                    for the various repos
###############################################################################
function parse_modules_repo_csv_and_build_cmd_args()
{
    local repos_csv="${1}"
    local index=0

    unset PARSED_EDGE_MODULES_REPO_ENV
    if [[ ! -z "${repos_csv}" ]]; then
        OIFS=$IFS
        IFS=${CSV_SEP}
        for repo in ${repos_csv}; do
            validate_and_parse_repository "${repo}"
            if [[ "${PARSED_REPO_RESULT}" == "0" ]]; then
                log_debug "Module Repo [${index}] Address: [${PARSED_REPO_ADDRESS}]"
                log_debug "Module Repo [${index}] Username: [${PARSED_REPO_USERNAME}]"
                log_debug "Module Repo [${index}] Password: [${PARSED_REPO_PASSWORD}]"
                PARSED_EDGE_MODULES_REPO_ENV+=("--env" "DockerRegistryAuth__${index}__serverAddress=${PARSED_REPO_ADDRESS}")
                PARSED_EDGE_MODULES_REPO_ENV+=("--env" "DockerRegistryAuth__${index}__username=${PARSED_REPO_USERNAME}")
                PARSED_EDGE_MODULES_REPO_ENV+=("--env" "DockerRegistryAuth__${index}__password=${PARSED_REPO_PASSWORD}")
                index=$((index+1))
            else
                log_error "Error: Invalid Repository ${repo}"
            fi
        done
        IFS=$OIFS
    fi
}

###############################################################################
# Implementation start the edge runtime.
# This routine installs the Edge Agent if not present on the device or if able
# a newer image is detected via the supplied EDGE_RUNTIME_IMG
#
# Return Ouput: None
# Globals Updated: None
###############################################################################
function start_edge_runtime()
{
    local status=$(get_status_edge_runtime 2> /dev/null)
    local perform_docker_run=0
    local perform_docker_update=0
    local perform_docker_start=0
    local cmd=

    if [[ "${status}" == "EDGE_RUNNING" ]]; then
        log_error "Edge runtime Is currently running." \
                  "Please stop or restart the Edge runtime and retry."
    elif [[ "${status}" == "EDGE_RESTARTING" ]]; then
        log_error "Error: Edge runtime Is currently restarting." \
                  "Please stop the runtime and retry."
    else
        docker_command_login "${EDGE_CONTAINER_REPO_ADDRESS}"  \
                             "${EDGE_CONTAINER_REPO_USERNAME}" \
                             "${EDGE_CONTAINER_REPO_PASSWORD}"

        docker_command_pull "${EDGE_RUNTIME_IMG}"
        if [[ "${DOCKER_CMD_OUTPUT}" == "updated" ]]; then
            perform_docker_update=1
        else
            if [[ "${status}" == "EDGE_UNAVAILABLE" ]]; then
                log_debug "Edge Runtime Container" \
                          "${EDGE_RUNTIME_CONTAINER_NAME} does not exist."
                perform_docker_update=1
            else
                perform_docker_start=1
            fi
        fi
    fi

    if [[ $perform_docker_start -eq 1 ]]; then
        docker_command_start_container "${EDGE_RUNTIME_CONTAINER_NAME}"
        echo "Edge Runtime Started."
    elif [[ $perform_docker_update -eq 1 ]]; then
        prepare_modules_filesystem
        generate_self_signed_certs_if_needed
        docker_command_create_network "${EDGE_RUNTIME_NETWORK_ID}"
        docker_command_remove_container "${EDGE_RUNTIME_CONTAINER_NAME}"

        # next run the edge runtime image
        declare -a run_cmd_args
        run_cmd_args+=("--name" "${EDGE_RUNTIME_CONTAINER_NAME}")
        run_cmd_args+=("--detach")
        run_cmd_args+=("--network" "${EDGE_RUNTIME_NETWORK_ID}")
        run_cmd_args+=("--publish" "8883:8883")
        run_cmd_args+=("--publish" "443:443")
        if [[ -z "${DOCKER_PORT}" ]]; then
            run_cmd_args+=("--volume" "${DOCKER_ENDPOINT}:${DOCKER_ENDPOINT}")
        else
            run_cmd_args+=("--publish" "${DOCKER_PORT}:${DOCKER_PORT}")
        fi
        run_cmd_args+=("--env" "DockerUri=${DOCKER_URI}")
        run_cmd_args+=("--env" "DeviceConnectionString=${IOTHUB_DEVICE_CONNECTION_STRING}")
        run_cmd_args+=("--env" "EdgeDeviceHostName=${EDGE_HUB_SERVER_DNS_NAME}")
        run_cmd_args+=("--env" "NetworkId=${EDGE_RUNTIME_NETWORK_ID}")
        parse_modules_repo_csv_and_build_cmd_args "${EDGE_MODULE_REPOSITORIES_CSV}"
        if [[ $DRY_RUN_MODE == OFF ]]; then
            local result=$(docker run "${run_cmd_args[@]}" "${PARSED_EDGE_MODULES_REPO_ENV[@]}" "${EDGE_RUNTIME_IMG}")
            [ $? -eq 0 ] || exit $?
        else
            echo "docker run ${run_cmd_args[@]} ${PARSED_EDGE_MODULES_REPO_ENV[@]} ${EDGE_RUNTIME_IMG}"
        fi
        echo "Edge Runtime Started."
    fi
}

###############################################################################
# Implementation stop the edge runtime.
# This routine detects if the Edge runtime container is running and if so
# stop it
#
# Return Ouput: None
# Globals Updated: None
###############################################################################
function stop_edge_runtime()
{
    local status=$(get_status_edge_runtime 2> /dev/null)

    if [[ "${status}" == "EDGE_UNAVAILABLE" ]]; then
        log_error "Edge Runtime Container ${EDGE_RUNTIME_CONTAINER_NAME}" \
                  "does not exist."
    elif [[ "${status}" == "EDGE_RESTARTING" ]]; then
        log_error "Edge runtime Is currently restarting. Please retry later."
    else
        if [[ "${status}" != "EDGE_RUNNING" ]]; then
            log_info "Edge runtime is already stopped."
        else
            docker_command_stop_container "${EDGE_RUNTIME_CONTAINER_NAME}"
        fi
        log_info "Stopping Edge Modules."
        docker_command_stop_by_label "${EDGE_AGENT_LABEL}"
        echo "Edge Runtime Stopped."
    fi
}

###############################################################################
# Implementation restart the edge runtime.
# This routine installs the Edge Agent if not present on the device or if able
# a newer image is detected via the supplied EDGE_RUNTIME_IMG. If the Edge
# runtime container is running, it will be restarted.
#
# Return Ouput: None
# Globals Updated: None
###############################################################################
function restart_edge_runtime()
{
    local status=$(get_status_edge_runtime 2> /dev/null)

    if [[ "${status}" == "EDGE_UNAVAILABLE" ]]; then
        start_edge_runtime
    elif [[ "${status}" == "EDGE_RESTARTING" ]]; then
        log_error "Error: Edge runtime Is currently restarting. Please retry later."
    else
        log_debug "Attempting to Restart Container: ${EDGE_RUNTIME_CONTAINER_NAME}"
        if [[ $DRY_RUN_MODE == OFF ]]; then
            local result=$(docker restart -t 3 "${EDGE_RUNTIME_CONTAINER_NAME}")
            [ $? -eq 0 ] || exit $?
        else
            local cmd="docker restart -t 3 ${EDGE_RUNTIME_CONTAINER_NAME}"
            echo "${cmd}"
        fi
        echo "Edge Runtime Restarted."
    fi
}

###############################################################################
# Implementation of the uninstall operation of the edge runtime.
#
# Return Ouput: None
# Globals Updated: None
###############################################################################
function uninstall_edge_runtime()
{
    local status=$(get_status_edge_runtime 2> /dev/null)

    if [[ "${status}" == "EDGE_UNAVAILABLE" ]]; then
        log_info "Edge Runtime Container ${EDGE_RUNTIME_CONTAINER_NAME}" \
                  "does not exist."
    else
        docker_command_stop_container "${EDGE_RUNTIME_CONTAINER_NAME}"
        docker_command_remove_container "${EDGE_RUNTIME_CONTAINER_NAME}"
    fi
    docker_command_stop_by_label "${EDGE_AGENT_LABEL}"
    docker_command_remove_by_label "${EDGE_AGENT_LABEL}"
    echo "Edge Runtime Uninstalled."
}

###############################################################################
# Central Handler For all Edge Commands
###############################################################################
function handle_edge_command()
{
    local cmd="${1}"
    verify_prerequisites "${EDGE_RUNTIME_COMMAND}" \
                         "${EDGE_USE_SELF_SIGNED_CERTS}"
    case "${cmd}" in
        "start" ) start_edge_runtime;;
        "restart" ) restart_edge_runtime;;
        "stop" ) stop_edge_runtime;;
        "uninstall" ) uninstall_edge_runtime;;
        "status" ) print_status_edge_runtime "true";;
        * ) usage;;
    esac
}

###############################################################################
# Main Script Execution
###############################################################################
process_args "$@"
handle_edge_command "${EDGE_RUNTIME_COMMAND}"
